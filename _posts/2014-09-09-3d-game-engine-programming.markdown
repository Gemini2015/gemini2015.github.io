---
layout:	post
title:	"3D Game Engine Programming - 整理" 
date:	2014-09-09 21:30:50 
categories:	game dev 
description: 从零开始，记录一个游戏引擎的设计过程
---


&emsp;&emsp;几周前，从同事那里拿过来Stefan Zerbst与Oliver Duvel合著的《3D Game Engine Programming》来看。
书是用电子版打印的，全英文。看起来还是有点吃力的。这本书的内容是从零开始，讲述如何实现一个3D游戏引擎。开发平台为Windows，图形接口使用的是DirectX。


游戏引擎的作用
--
关于游戏引擎的作用，实际上没有严格的定义，其**主要目的是为了代码重用**
本书里面里面给出了几个定义，我觉得有点难于理解和翻译，所以把原文也摘抄下来：

1.  Manage all data in its responsibility area
    管理其责任范围内的所有数据。游戏引擎的一个功能就是游戏资产管理，游戏资产是指游戏中要使用到的资源如图片、音频、字体、配置等。
1.  Compute data
    计算数据。指的是除开游戏逻辑部分，属于游戏引擎负责的任务的计算。
1.  Pass data to its following instance
    将数据传给其子实例。个人认为子实例或许指的是游戏引擎中用到的具体实例，如DirectX中创建的实例等。
1.  Accept data
    接受数据。接受数据应该是指游戏引擎可以接受外部传进来的数据，如通过输入设备，或是游戏逻辑部分计算的数据。

一般来讲，游戏引擎应该独立于具体的游戏，表面上看就是游戏引擎代码要能独立编译，不能有对具体游戏逻辑代码的依赖。从内部来分析，就是游戏引擎在设计的时候应该是能兼容某一类游戏，提供弹性的接口。


3D游戏引擎 vs 3D 引擎
--

首先，必须得区分3D游戏引擎和3D引擎的区别。一个游戏引擎包含很多子系统，如图形引擎，音效引擎，物理引擎等。
3D引擎一般主要指图形引擎，负责3D图形的计算和渲染。也就是说3D引擎主要是负责游戏中图形图像的相关处理。
一般来说一款游戏引擎主要包含如下几个子系统:

1.  3D图形引擎（本书主要讲述的是3D游戏引擎的设计，所以对应的是3D图形引擎）
1.  音效引擎
1.  输入系统：键盘、鼠标、操作杆等
1.  网络
1.  物理引擎
1.  AI


以上只是一个游戏引擎的大体结构，具体的运行时游戏引擎架构，我觉得可以参考Jeff Lander和Matt Whiting合著的《[游戏引擎架构](http://baike.baidu.com/view/12054333.htm)》中第26页的图1.11。该图给出了从底层硬件，到顶层游戏逻辑的详细结构。有兴趣的可以看看。这本书虽然看起来很厚，但是内容不是很深，广度是还可以，比较适合作为游戏行业的入门书籍，帮助了解一些基本术语和知识。后面，我也会把这本书的笔记整理出来。


**游戏引擎一般是面向接口设计的，大部分子系统都使用了单例模式**


本书引擎结构
--
在本书中，作者实现了一个简单的3D游戏引擎，包括以下几个模块：

1.  RenderSystem：渲染系统。
1.  Audio：音效系统
1.  Input：输入模块
1.  Network：网络

除此之外，还有一个 3D 模型系统，以及一些工具类。


RenderSystem
--
渲染系统，即3D图形引擎，主要负责渲染设备的初始化和管理，提供一组用于渲染3D图形的接口。
在具体编程实现上体现为，首先设计一个接口，提供了该引擎上层模块需要用到的基本图形接口。然后在选取一个具体的图形接口如DirectX或者OpenGL来实现这个接口。当然，在设计这个接口的时候也应该使接口与具体实现无关。**在游戏引擎中，最好不要直接使用具体的图形接口提供的函数。**


3D 模型系统
--
该系统实现了对基础3D模型的建模，同时提供了相关的计算方法，**这个系统主要涉及到计算机图形学中算法的应用。**
这些3D模型包括：

- Vector：用来表示向量或三维坐标。为了便于与4*4矩阵进行计算，通常使用四维Vector，第四个值大部分时候没有意义，置为1。
- Matrix：4*4矩阵，常用于坐标变换。
- Ray：射线（或线段），其属性包括一个起始坐标，和一个方向向量。可以用于模拟子弹的轨迹。
- Plane：平面
- AABB：Axis-Aligned Bounding Box，坐标轴对齐的有界盒子
- OBB：Oriented Bounding Box
- Polygon：多边形

对于这些几何模型，都有一些相关的计算：

- 基本运算，如Vector的+、-、/、点乘、叉乘等
- 相交计算：判断两个物体是否相交
- 几何变换：平移、旋转等
- 裁剪


纹理、材质、光照
--
以上的3D模型只是构成了3维世界中，物体的几何特性。真正展现在显示器上的，是各种各样的图片。
比如，一个长方体，长宽高，位置等都是它的几何信息。可以用一个AABB来表示。但是这些信息并不能构成它到底看起来是什么样子。

**任何一个物体，要想绘制出来，首先必须得有一个材质。**比如一个用木头做的长方体。

（实际上，这可以从物理学上分析，一个没有材质的物体，是不可能反射光的，而人眼看到物体，都是因为物体能反射光到人的眼睛里）
不同的材质，看起来的样子不同，主要是因为光线的反射系数不同（个人理解，具体请参考光学书籍）

纹理实际上是2D图形，比如木头上的一个年轮可以认为是一个纹理，一个坦克模型上绘制的迷彩等，也可以认为是纹理，纹理可以用来表现物体的细节。

所以纹理能影响物体看起来的样子，除此之外，还有另外一个因素能影响物体看起来的样子，那就是光照。
光照不同，物体反应在显示器上的样子也不同。3D引擎中，有以下类型的光照：

1.  **Ambient Light**：环境光，其特定是对于场景内的所有物体，其亮度都是相同的。在表示上可以采用一个`RGBA颜色值`、`强度`来表示。
2.  **Direct Light**：直射光，这类光源又可分为3种
    1.  **Directional Light**：也可称为Parallel Light，平行光，如太阳光。这类光源的属性有`方向`,`RGBA颜色值`,`强度`。
    2.  **Point Light**：点光源，类似于没有没有灯罩的电灯泡，其特点是向所有方向发射光线。这类光源的属性有`位置`,`RGBA颜色值`,`强度`。其光线的方向是需要计算的。
    3.  **Spot Light**：聚光灯，类似于手电筒，其光线向某一个区域发射，通常是圆形区域。这类光源的属性有`位置`，`方向`,`RGBA颜色值`,`强度`,`内圆锥夹角`，`外圆锥夹角`。Spot Light照在平面上看起来是一个圆环，内圆锥夹角对应的半径为R1的圆，外圆锥夹角对应的是半径为R2的夹角，R2>R1,在半径0 - R1的区域，亮度较高，在R1 - R2的区域亮度逐渐降低，大于R2的区域，基本上为环境光状态。


未完待续……


