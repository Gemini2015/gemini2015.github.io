---
layout: post
title: 关于X11
date: 2015-03-11 22:43:00
categories: game dev 
description: 关于X11的一些笔记
---


X Window系统是在Unix和类Unix系统上建立图形用户界面的标准工具包和协议，**11**代表版本11。X Window系统基于C/S(客户端/服务器)模型，与通常意义上的**服务器**不同的是，X Window的服务器一般是指使用者本地的计算机。**X Window只是一套协议**，现在在类Unix系统中较常用的实现是**X.Org的参考实现**。

在Linux平台上，与X Window系统相关的结构和操作都定义在`Xlib`中，`Xlib`库的的主要作用是**窗口管理**和**事件处理**。

1984年，Bob Scheifler 和 Jim Gettys 制订了X的早期原则：

- 除非没有它就无法完成一个真正完整的应用程序，否则不用增加新的功能。
- 决定一个系统不是什么和决定它是什么同样重要。与其去适应整个世界的需要，宁可使得系统可以扩展，如此才能以持续兼容的方式来满足新增需求
- 只有完全没实例时，才会比只有一个实例来的糟。
- 如果问题没完全弄懂，最好不要去解决它
- 如果可以通过10％的工作量得到90％的预期效果，应该用更简单的办法解决。
- 尽量避免复杂性。
- 提供机制而不是策略，有关用户接口的开发实现，交给实际应用者自主。

事实上，已经有很多成熟的对X11进行封装的库，但是我目前并没有使用，我想先从底层原生API开始学习，以后再考虑使用封装库。

## 程序模型
与Win32程序一样，基于X11的程序也是由一个循环构成，收到消息，处理消息。

```
while(connected to server)
{
    Receive next event
    Handle the event
}
```

>Graphical Programming in X basically follows the asynchronous model i.e. "I won't do anything until you ask me to".

## 实体对象

-   Display：X Window采用C/S模型，Display可以认为是Client与Server之间的连接的句柄。从Client的角度来讲，可以将Display看成一个Server
-   Window：作为一个句柄，代表一个窗口实例。
-   Visual
-   XEvent：表示一个窗口事件。


## 窗口相关操作

### 创建
既然是C/S模型，那么在进行任何操作之前，都得先创建一个与服务器的连接。使用`XOpenDisplay`函数就可以完成该任务，该函数返回一个`Display`结构的指针。后面的对于X11的操作基本上都基于这个连接。
接着，可以组织一些窗口的参数，包括父窗口句柄，窗口位置，大小等属性。以这些参数调用`XCreateWindow`或`XCreateSimpleWindow`就可以创建一个窗口，新创建的窗口默认是未映射的(Unmapped)。

```
// 建立连接
Display *display = XOpenDisplay(NULL);

// 准备参数
Visual *visual = DefaultVisual(display, 0);
Window parent = DefaultRootWindow(display);
int x = 0, y = 0;
int width = 320, height = 200;
int border_width = 0;
int depth = CopyFromParent;
unsigned int class = CopyFromParent;
unsigned long value_mask = 0;
XSetWindowAttributes *pAttr = NULL;

// 创建窗口
Window window = XCreateWindow(display, parent, x, y, width, height, border_width, depth, class, visual, value_mask, pAttr);
```

### 属性
对于一个窗口来说，经常会使用到的属性无外乎窗口标题、大小、位置、颜色深度、可见性等。

-   窗口标题
    
    ```
    Display *display;
    Window window;
    // 设置标题
    XStoreName(display, window, "Hello X11");

    char buf[256];
    // 获取标题
    XFetchName(display, window, &buf);
    ```
    事实上`XStoreName`不一定会设置窗口标题。查看`XStoreName`的手册，有这样的解释:

    > The `XStoreName` function assigns the name passed to window_name to the specified window.  A window manager can display the window name in some prominent place, such as the title bar, to allow users to identify windows easily.

    也就是说，具体的行为是由窗口管理器(Window Manager)定义的。至少在我运行的平台上，该函数可以设置窗口标题。

-   窗口位置
    
    ```
    Display *display;
    Window window;
    Window root, parent, *child;
    unsigned int nchild = 0;
    // 查询window对应的 root window
    // 一般root window 代表桌面
    XQueryTree(display, window, &root, &parent, &child, &nchild);
    if(child)
        XFree(child);
    int x, y;
    Window cw;
    // 将window的原点(0, 0)转换到root window坐标系中
    XTranslateCoordinates(display, window, root, 0, 0, &x, &y, &cw);
    ```
    关于窗口位置的获取，有许多人会使用下面的方法：

    ```
    Display *display;
    Window window;
    XWindowAttributes attr;
    XGetWindowAttributes(display, window, &attr);
    ```
    代码意思很清楚，获取窗口的属性，而且`attr`中也有`x,y`字段。但是实际上这样做是得不到结果的。得到的`x,y`一直都是`0,0`。目前还没弄明白`attr`里面的`x,y`字段到底有什么用。

-   窗口大小
    
    ```
    Display *display;
    Window window;
    XWindowAttributes attr;
    XGetWindowAttributes(display, window, &attr);
    int window_widht = attr.width;
    int window_height = attr.height;
    ```
    虽然不能获取到位置，但是却可以获取到窗口的大小。需要注意的是，**上面获取到的宽高指的是窗口内部，不包括边框大小。**

## 窗口事件


## 杂项

- [Linux上的OpenGL编程](https://www.opengl.org/wiki/OpenGL_in_Linux:_Programming "OpenGL in Linux: Programming")，简单介绍了X11与OpenGL的关联操作。
